<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arduino Data Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #1a1a1a;
        color: white;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 20px;
      }

      .status {
        background-color: #333;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .controls {
        display: flex;
        gap: 10px;
      }

      button {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }

      button:hover {
        background-color: #45a049;
      }

      button:disabled {
        background-color: #666;
        cursor: not-allowed;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .legend-color {
        width: 20px;
        height: 3px;
        border-radius: 2px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 20px;
      }

      .stat-card {
        background-color: #333;
        padding: 15px;
        border-radius: 5px;
        text-align: center;
      }

      .stat-value {
        font-size: 24px;
        font-weight: bold;
        margin: 5px 0;
      }

      .stat-label {
        font-size: 12px;
        color: #ccc;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Arduino Data Visualization</h1>
      </div>

      <div class="status">
        <div id="connection-status">Connecting...</div>
        <div class="controls">
          <button id="clear-btn">Clear Data</button>
          <button id="pause-btn">Pause</button>
          <button id="export-btn">Export Data</button>
        </div>
      </div>

      <div id="graph-container"></div>

      <!-- Remove old legend and stats sections from HTML -->
    </div>

    <script>
      // Global variables
      let socket;
      let dataPoints = [];
      let isPaused = false;
      let maxDataPoints = 50;
      let graphWidth, graphHeight;
      let graphX, graphY;
      let minY = 0,
        maxY = 1024; // Arduino analog range
      let autoScale = true;

      // Colors for each data stream
      const colors = {
        left_1: [255, 107, 107], // Red
        left_2: [255, 159, 67], // Orange
        left_3: [255, 221, 89], // Yellow
        left_4: [38, 222, 129], // Green
        right_1: [78, 205, 196], // Teal
        right_2: [69, 183, 209], // Blue
        right_3: [75, 123, 236], // Indigo
        right_4: [165, 94, 234], // Purple
      };
      const portLabels = [
        "Left 1",
        "Left 2",
        "Left 3",
        "Left 4",
        "Right 1",
        "Right 2",
        "Right 3",
        "Right 4",
      ];
      const portKeys = [
        "left_1",
        "left_2",
        "left_3",
        "left_4",
        "right_1",
        "right_2",
        "right_3",
        "right_4",
      ];

      function setup() {
        // Set up a canvas large enough for 2 rows x 4 columns of mini-plots
        let plotWidth = 280;
        let plotHeight = 180;
        let paddingX = 40;
        let paddingY = 60;
        let cols = 4;
        let rows = 2;
        let titleHeight = 50; // Extra space for row titles
        let canvasWidth = cols * plotWidth + (cols + 1) * paddingX;
        let canvasHeight = rows * plotHeight + (rows + 1) * paddingY + titleHeight;
        let canvas = createCanvas(canvasWidth, canvasHeight);
        canvas.parent("graph-container");
        initializeWebSocket();
        setupEventListeners();
      }

      function initializeWebSocket() {
        socket = io("http://localhost:5002");

        socket.on("connect", function () {
          updateStatus("Connected", "#4CAF50");
          console.log("Connected to server");
        });

        socket.on("disconnect", function () {
          updateStatus("Disconnected", "#f44336");
          console.log("Disconnected from server");
        });

        socket.on("arduino_data", function (data) {
          if (!isPaused) {
            handleNewData(data);
          }
        });

        socket.on("server_status", function (data) {
          console.log("Server status:", data.message);
        });
      }

      function handleNewData(data) {
        // Add timestamp for x-axis
        data.displayTime = millis();

        // Add to data array
        dataPoints.push(data);

        // Keep only recent data points
        if (dataPoints.length > maxDataPoints) {
          dataPoints.shift();
        }

        // Update auto-scaling
        if (autoScale) {
          updateScale();
        }

        // Update real-time stats
        updateStats(data);

        // Calculate EMA for the new data point
        data.ema = {};
        for (let key of portKeys) {
            data.ema[key] = calculateEMA(key, dataPoints.concat([data]), dataPoints.length);
        }
      }

      function updateScale() {
        if (dataPoints.length === 0) return;

        let tempMinY = Infinity;
        let tempMaxY = -Infinity;

        dataPoints.forEach((point) => {
          tempMinY = Math.min(
            tempMinY,
            point.left_1,
            point.left_2,
            point.left_3,
            point.left_4,
            point.right_1,
            point.right_2,
            point.right_3,
            point.right_4
          );
          tempMaxY = Math.max(
            tempMaxY,
            point.left_1,
            point.left_2,
            point.left_3,
            point.left_4,
            point.right_1,
            point.right_2,
            point.right_3,
            point.right_4
          );
        });

        // Add some padding
        let padding = (tempMaxY - tempMinY) * 0.1;
        minY = tempMinY - padding;
        maxY = tempMaxY + padding;

        // Ensure minimum range
        if (maxY - minY < 10) {
          let center = (maxY + minY) / 2;
          minY = center - 5;
          maxY = center + 5;
        }
      }

      function updateStats(data) {
        document.getElementById("left-1-value").textContent =
          data.left_1.toFixed(1);
        document.getElementById("left-2-value").textContent =
          data.left_2.toFixed(1);
        document.getElementById("left-3-value").textContent =
          data.left_3.toFixed(1);
        document.getElementById("left-4-value").textContent =
          data.left_4.toFixed(1);
        document.getElementById("right-1-value").textContent =
          data.right_1.toFixed(1);
        document.getElementById("right-2-value").textContent =
          data.right_2.toFixed(1);
        document.getElementById("right-3-value").textContent =
          data.right_3.toFixed(1);
        document.getElementById("right-4-value").textContent =
          data.right_4.toFixed(1);
      }

      function updateStatus(message, color) {
        const statusEl = document.getElementById("connection-status");
        statusEl.textContent = message;
        statusEl.style.color = color;
      }

      function draw() {
        background(26, 26, 26);
        let plotWidth = 280;
        let plotHeight = 180;
        let paddingX = 40;
        let paddingY = 60;
        let cols = 4;
        let rows = 2;
        
        // Draw row titles
        fill(255);
        noStroke();
        textAlign(CENTER, TOP);
        textSize(18);
        textStyle(BOLD);
        text("Left Sensors", paddingX + (plotWidth + paddingX) * 2, paddingY - 30);
        text("Right Sensors", paddingX + (plotWidth + paddingX) * 2, paddingY + plotHeight + paddingY - 30);
        textStyle(NORMAL);
        
        for (let i = 0; i < 8; i++) {
          let col = i % cols;
          let row = Math.floor(i / cols);
          let x0 = paddingX + col * (plotWidth + paddingX);
          let y0 = paddingY + row * (plotHeight + paddingY);
          drawMiniPlot(
            x0,
            y0,
            plotWidth,
            plotHeight,
            portKeys[i],
            portLabels[i],
            colors[portKeys[i]]
          );
        }
      }

      function drawMiniPlot(x, y, w, h, key, label, color) {
        // Draw background
        fill(40, 40, 40);
        stroke(80);
        rect(x, y, w, h, 8);
        // Draw axes
        stroke(200);
        strokeWeight(1);
        // Y axis
        line(x + 40, y + 10, x + 40, y + h - 30);
        // X axis
        line(x + 40, y + h - 30, x + w - 10, y + h - 30);
        // Y axis labels (0, 2500, 5000)
        fill(200);
        noStroke();
        textAlign(RIGHT, CENTER);
        textSize(10);
        text("5000", x + 35, y + 20);
        text("2500", x + 35, y + (h - 20) / 2);
        text("0", x + 35, y + h - 30);
        // X axis label
        textAlign(CENTER, TOP);
        textSize(10);
        text("Time", x + w / 2, y + h - 18);
        // Draw original data line (commented out to show only smoothed line)
        /*
        let n = dataPoints.length;
        if (n > 1) {
          stroke(color[0], color[1], color[2]);
          strokeWeight(2);
          noFill();
          beginShape();
          for (let i = 0; i < n; i++) {
            let px = map(i, 0, maxDataPoints - 1, x + 40, x + w - 10);
            let cappedValue = Math.max(0, Math.min(5000, dataPoints[i][key]));
            let py = map(cappedValue, 0, 5000, y + h - 30, y + 10);
            vertex(px, py);
          }
          endShape();
        }
        */
        // Draw current value dot
        let n = dataPoints.length;
        if (n > 0) {
          let latest = Math.max(0, Math.min(5000, dataPoints[n - 1][key]));
          let px = x + w - 15;
          let py = map(latest, 0, 5000, y + h - 30, y + 10);
          fill(color[0], color[1], color[2]);
          stroke(255);
          ellipse(px, py, 8, 8);
          // Show latest value
          noStroke();
          fill(230);
          textAlign(LEFT, TOP);
          textSize(12);
          text(latest.toFixed(1), x + w - 50, y + 12);
        }
        // Draw label
        noStroke();
        fill(color[0], color[1], color[2]);
        textAlign(LEFT, TOP);
        textSize(14);
        text(label, x + 45, y + 12);

        // Draw smooth data line
        if (dataPoints.length > 1) {
            // Plot the smoothed data using stored values
            stroke(color[0], color[1], color[2]);
            strokeWeight(2);
            noFill();
            beginShape();
            for (let i = 0, n = dataPoints.length; i < n; i++) {
                let smoothedValue;
                if (dataPoints[i].ema && dataPoints[i].ema[key] !== undefined) {
                    smoothedValue = dataPoints[i].ema[key];
                } else {
                    // Fallback to raw value if EMA doesn't exist
                    smoothedValue = dataPoints[i][key];
                }
                
                if (smoothedValue < 0) {
                    smoothedValue = 0;
                } else if (smoothedValue > 5000) {
                    smoothedValue = 5000;
                }
                
                let px = map(i, 0, maxDataPoints - 1, x + 40, x + w - 10);
                let py = map(smoothedValue, 0, 5000, y + h - 30, y + 10);
                vertex(px, py);
            }
            endShape();
        }
      }

    // Exponential Moving Average - more stable than simple moving average
    // a higher alpha value means more weight to the current value ! 
    function calculateEMA(key, data, index, alpha = 0.8) {
        if (index === 0) {
            return data[0][key]; // if no previous value, return the first value
        }
        let currentValue = data[index][key];
        let previousEMA = data[index - 1].ema ? data[index - 1].ema[key] : data[index - 1][key]; // previous EMA value or previous raw value if no EMA value
        return alpha * currentValue + (1 - alpha) * previousEMA; // averages prevEMA & currentEMA, weighting the current value more heavily (alpha > 0.5)
    }

      function setupEventListeners() {
        document
          .getElementById("clear-btn")
          .addEventListener("click", function () {
            dataPoints = [];
          });

        document
          .getElementById("pause-btn")
          .addEventListener("click", function () {
            isPaused = !isPaused;
            this.textContent = isPaused ? "Resume" : "Pause";
            this.style.backgroundColor = isPaused ? "#ff9800" : "#4CAF50";
          });

        document
          .getElementById("export-btn")
          .addEventListener("click", function () {
            exportData();
          });
      }

      function exportData() {
        if (dataPoints.length === 0) {
          alert("No data to export");
          return;
        }

        let csv =
          "timestamp,left_1,left_2,left_3,left_4,right_1,right_2,right_3,right_4\n";
        dataPoints.forEach((point) => {
          csv += `${point.timestamp},${point.left_1},${point.left_2},${point.left_3},${point.left_4},${point.right_1},${point.right_2},${point.right_3},${point.right_4}\n`;
        });

        let blob = new Blob([csv], { type: "text/csv" });
        let url = window.URL.createObjectURL(blob);
        let a = document.createElement("a");
        a.href = url;
        a.download = "arduino_data.csv";
        a.click();
        window.URL.revokeObjectURL(url);
      }

      // Keyboard shortcuts
      function keyPressed() {
        if (key === "c" || key === "C") {
          dataPoints = [];
        }
        if (key === "p" || key === "P") {
          isPaused = !isPaused;
          document.getElementById("pause-btn").click();
        }
        if (key === "s" || key === "S") {
          autoScale = !autoScale;
          if (!autoScale) {
            minY = 0;
            maxY = 1024;
          }
        }
      }

      // Handle window resize
      function windowResized() {
        // Update graph dimensions if needed
        graphWidth = width - 80;
        graphHeight = height - 80;
      }
    </script>
  </body>
</html>
